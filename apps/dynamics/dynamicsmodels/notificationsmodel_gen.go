// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.3

package dynamicsmodels

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/cache"
	"github.com/zeromicro/go-zero/core/stores/sqlc"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	notificationsFieldNames          = builder.RawFieldNames(&Notifications{})
	notificationsRows                = strings.Join(notificationsFieldNames, ",")
	notificationsRowsExpectAutoSet   = strings.Join(stringx.Remove(notificationsFieldNames, "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	notificationsRowsWithPlaceHolder = strings.Join(stringx.Remove(notificationsFieldNames, "`id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"

	cacheNotificationsIdPrefix = "cache:notifications:id:"
	cacheNotificationsUserIdCountPrefix = "cache:notifications:user_id:count:"
)

type (
	notificationsModel interface {
		Insert(ctx context.Context, data *Notifications) (sql.Result, error)
		FindOne(ctx context.Context, id string) (*Notifications, error)
		Update(ctx context.Context, data *Notifications) error
		UpdateByUserId(ctx context.Context, userId string) error
		Delete(ctx context.Context, id string) error
		FindByUserIdWithPage(ctx context.Context, userId string,limit,offset int32) ([]*Notifications, error)
		FindByUserIdAndPostId(ctx context.Context, userId string, postId string) (*Notifications, error)
		FindByUserIdAndIsNotRead(ctx context.Context, userId string) (int32, error)
		FindByUserIdAndType(ctx context.Context, userId,userType string) ([]*Notifications, error)
	}

	defaultNotificationsModel struct {
		sqlc.CachedConn
		table string
	}

	Notifications struct {
		Id            string         `db:"id"`
		UserId        string         `db:"user_id"`
		Type          string         `db:"type"`
		TriggerUserId string         `db:"trigger_user_id"`
		PostId        string         `db:"post_id"`
		CommentId     sql.NullString `db:"comment_id"`
		CreatedAt     time.Time      `db:"created_at"`
		IsRead        bool           `db:"is_read"`
	}
)

func newNotificationsModel(conn sqlx.SqlConn, c cache.CacheConf, opts ...cache.Option) *defaultNotificationsModel {
	return &defaultNotificationsModel{
		CachedConn: sqlc.NewConn(conn, c, opts...),
		table:      "`notifications`",
	}
}

func (m *defaultNotificationsModel) Delete(ctx context.Context, id string) error {
	notificationsIdKey := fmt.Sprintf("%s%v", cacheNotificationsIdPrefix, id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("delete from %s where `id` = ?", m.table)
		return conn.ExecCtx(ctx, query, id)
	}, notificationsIdKey)
	return err
}
func (m *defaultNotificationsModel) FindByUserIdAndPostId(ctx context.Context, userId string, postId string) (*Notifications, error) {
	var resp Notifications
	query := fmt.Sprintf("SELECT %s FROM %s WHERE `user_id` = ? and `post_id` = ?", notificationsRows, m.table)
	err := m.QueryRowNoCacheCtx(ctx,&resp,query,userId,postId)
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
func (m *defaultNotificationsModel) FindByUserIdAndType(ctx context.Context, userId,userType string) ([]*Notifications, error) {
	var resp []*Notifications
	query := fmt.Sprintf("SELECT %s FROM %s WHERE `user_id` = ? AND `type` = ?", notificationsRows, m.table)
	err := m.QueryRowsNoCacheCtx(ctx, &resp, query, userId, userType)
	switch err {
	case nil:
		return resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
func (m *defaultNotificationsModel) FindByUserIdWithPage(ctx context.Context, userId string,limit,offset int32) ([]*Notifications, error) {
	var resp []*Notifications
	query := fmt.Sprintf("SELECT %s FROM %s WHERE `user_id` = ? ORDER BY `created_at` DESC LIMIT ? OFFSET ?", notificationsRows, m.table)
	err := m.QueryRowsNoCacheCtx(ctx,&resp,query,userId,limit,offset)
	switch err {
	case nil:
		return resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}
func (m *defaultNotificationsModel) FindByUserIdAndIsNotRead(ctx context.Context, userId string) (int32, error) {
	var resp int32
	query := fmt.Sprintf("select COUNT(1) from %s where `user_id` = ? and `is_read` = false", m.table)
	err := m.QueryRowNoCacheCtx(ctx, &resp, query, userId)
	switch err {
	case nil:
		return resp, nil
	case sqlc.ErrNotFound:
		return 0, ErrNotFound
	default:
		return 0, err
	}
}
func (m *defaultNotificationsModel) FindOne(ctx context.Context, id string) (*Notifications, error) {
	notificationsIdKey := fmt.Sprintf("%s%v", cacheNotificationsIdPrefix, id)
	var resp Notifications
	err := m.QueryRowCtx(ctx, &resp, notificationsIdKey, func(ctx context.Context, conn sqlx.SqlConn, v any) error {
		query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", notificationsRows, m.table)
		return conn.QueryRowCtx(ctx, v, query, id)
	})
	switch err {
	case nil:
		return &resp, nil
	case sqlc.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultNotificationsModel) Insert(ctx context.Context, data *Notifications) (sql.Result, error) {
	notificationsIdKey := fmt.Sprintf("%s%v", cacheNotificationsIdPrefix, data.Id)
	ret, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?)", m.table, notificationsRowsExpectAutoSet)
		return conn.ExecCtx(ctx, query, data.Id, data.UserId, data.Type, data.TriggerUserId, data.PostId, data.CommentId, data.IsRead)
	}, notificationsIdKey)
	return ret, err
}
func (m *defaultNotificationsModel) UpdateByUserId(ctx context.Context, userId string) error {
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set `is_read` = true where `user_id` = ? and `is_read` = false", m.table)
		return conn.ExecCtx(ctx,query,userId)
	})
	return err
}
func (m *defaultNotificationsModel) Update(ctx context.Context, data *Notifications) error {
	notificationsIdKey := fmt.Sprintf("%s%v", cacheNotificationsIdPrefix, data.Id)
	_, err := m.ExecCtx(ctx, func(ctx context.Context, conn sqlx.SqlConn) (result sql.Result, err error) {
		query := fmt.Sprintf("update %s set %s where `id` = ?", m.table, notificationsRowsWithPlaceHolder)
		return conn.ExecCtx(ctx, query, data.UserId, data.Type, data.TriggerUserId, data.PostId, data.CommentId, data.IsRead, data.Id)
	}, notificationsIdKey)
	return err
}

func (m *defaultNotificationsModel) formatPrimary(primary any) string {
	return fmt.Sprintf("%s%v", cacheNotificationsIdPrefix, primary)
}

func (m *defaultNotificationsModel) queryPrimary(ctx context.Context, conn sqlx.SqlConn, v, primary any) error {
	query := fmt.Sprintf("select %s from %s where `id` = ? limit 1", notificationsRows, m.table)
	return conn.QueryRowCtx(ctx, v, query, primary)
}

func (m *defaultNotificationsModel) tableName() string {
	return m.table
}
